<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>終極彈幕大師 - 升級版</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #000; /* Fallback */
            overflow: hidden; /* NEW: Hide overflowing canvas during screen shake */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            background: linear-gradient(180deg, #000428, #004e92); /* Moved from game-container */
        }
        .ui {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        /* NEW: Pause Button Style */
        .pause-btn {
            position: absolute;
            top: 60px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            cursor: pointer;
        }
        .bars {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 180px;
        }
        .bar {
            height: 16px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #fff;
            border-radius: 8px;
            margin-bottom: 6px;
            overflow: hidden;
        }
        .bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        .health-fill { background: linear-gradient(90deg, #ff4757, #ff6b7d); }
        .shield-fill { background: linear-gradient(90deg, #00d4ff, #0abde3); }
        .special-fill { background: linear-gradient(90deg, #ffd700, #ffb347); }
        
        .combo {
            position: absolute;
            top: 100px;
            right: 15px;
            text-align: right;
            font-size: 18px;
            font-weight: bold;
        }
        .combo-multiplier {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }
        
        .boss-health {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #ff4757;
            border-radius: 10px;
            display: none;
        }
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4757, #ff6b7d);
            border-radius: 8px;
            transition: width 0.3s ease;
        }
        
        .special-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.3);
            border: 3px solid rgba(255, 215, 0, 0.6);
            color: white;
            font-size: 12px;
            font-weight: bold;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .special-btn:active {
            background: rgba(255, 215, 0, 0.6);
            transform: translateX(-50%) scale(0.95);
        }
        .special-btn.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
        
        /* MODIFIED: Common class for overlays */
        .screen-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 300;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00d4ff;
            max-width: 90vw;
        }
        .start-screen { display: block; }
        .game-over { display: none; border-color: #ff4757; }
        .pause-screen { display: none; border-color: #ffd700; } /* NEW */
        
        .btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #00d4ff, #0abde3);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn:active { transform: scale(0.95); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            text-align: left;
            font-size: 14px;
        }
        
        .slowmo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 150, 255, 0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .slowmo-overlay.active { opacity: 1; }
        
        .achievement-popup {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.9);
            color: black;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            display: none;
            z-index: 250;
            animation: slideDown 0.5s ease;
        }
        
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <canvas id="canvas"></canvas>
        <div class="slowmo-overlay" id="slowmoOverlay"></div>
        
        <div class="start-screen screen-overlay" id="startScreen">
            <h1>🚀 終極彈幕大師 🚀</h1>
            <p>觸控移動 | 自動射擊 | 收集道具</p>
            <div class="stats-grid">
                <div>最高分: <span id="displayHighScore">0</span></div>
                <div>總遊戲: <span id="displayTotalGames">0</span></div>
                <div>總擊殺: <span id="displayTotalKills">0</span></div>
                <div>成就數: <span id="displayAchievements">0</span></div>
            </div>
            <button class="btn" onclick="game.startGame()">開始遊戲</button>
        </div>
        
        <div class="ui">
            <div>分數: <span id="score">0</span></div>
            <div>等級: <span id="level">1</span></div>
            <div>生命: <span id="lives">3</span></div>
            <div>炮台: <span id="cannons">1</span></div>
            <div>擊殺: <span id="kills">0</span></div>
            <div>擦彈: <span id="graze">0</span></div> </div>
        
        <div class="pause-btn" id="pauseBtn">⏸</div>
        
        <div class="bars">
            <div class="bar"><div class="bar-fill health-fill" id="healthFill"></div></div>
            <div class="bar"><div class="bar-fill shield-fill" id="shieldFill"></div></div>
            <div class="bar"><div class="bar-fill special-fill" id="specialFill"></div></div>
        </div>
        
        <div class="combo">
            <div>連擊: <span id="combo">0</span></div>
            <div class="combo-multiplier">x<span id="multiplier">1</span></div>
        </div>
        
        <div class="boss-health" id="bossHealth">
            <div class="boss-health-fill" id="bossHealthFill"></div>
        </div>
        
        <button class="special-btn disabled" id="specialBtn">慢動作</button>
        
        <div class="achievement-popup" id="achievementPopup"></div>
        
        <div class="game-over screen-overlay" id="gameOver">
            <h2>🎮 遊戲結束</h2>
            <div id="finalStats"></div>
            <div id="newAchievements"></div>
            <button class="btn" onclick="game.restart()">重新開始</button>
            <button class="btn" onclick="game.backToMenu()">返回主選單</button>
        </div>

        <div class="pause-screen screen-overlay" id="pauseScreen">
            <h2>⏸ 已暫停</h2>
            <button class="btn" onclick="game.togglePause()">繼續遊戲</button>
            <button class="btn" onclick="game.backToMenu()">返回主選單</button>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                this.loadData();
                this.setupControls();
                
                // NEW: Sound Effects Setup
                this.setupAudio();

                // NEW: Parallax Background Setup
                this.setupBackground();
                
                this.initGame();
                this.loop();
            }

            // ... (setupCanvas, loadData, saveData, updateStartScreen are mostly unchanged) ...
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.w = this.canvas.width;
                this.h = this.canvas.height;
            }
            
            loadData() {
                this.data = {
                    highScore: parseInt(localStorage.getItem('bhHighScore') || '0'),
                    totalGames: parseInt(localStorage.getItem('bhTotalGames') || '0'),
                    totalKills: parseInt(localStorage.getItem('bhTotalKills') || '0'),
                    achievements: JSON.parse(localStorage.getItem('bhAchievements') || '[]')
                };
                this.updateStartScreen();
            }
            
            saveData() {
                localStorage.setItem('bhHighScore', this.data.highScore);
                localStorage.setItem('bhTotalGames', this.data.totalGames);
                localStorage.setItem('bhTotalKills', this.data.totalKills);
                localStorage.setItem('bhAchievements', JSON.stringify(this.data.achievements));
            }
            
            updateStartScreen() {
                document.getElementById('displayHighScore').textContent = this.data.highScore;
                document.getElementById('displayTotalGames').textContent = this.data.totalGames;
                document.getElementById('displayTotalKills').textContent = this.data.totalKills;
                document.getElementById('displayAchievements').textContent = this.data.achievements.length;
            }

            // NEW: Setup for audio files
            setupAudio() {
                this.sfx = {
                    shoot: new Audio('shoot.wav'),
                    hit: new Audio('hit.wav'),
                    explosion: new Audio('explosion.wav'),
                    powerup: new Audio('powerup.wav'),
                    laser: new Audio('laser.wav'),
                    playerHit: new Audio('playerHit.wav')
                };
                // You can adjust volume for all sounds here
                Object.values(this.sfx).forEach(s => s.volume = 0.5);
            }

            // NEW: Helper to play sound
            playSound(sound) {
                if (sound && sound.readyState >= 2) {
                    sound.currentTime = 0;
                    sound.play();
                }
            }
            
            // NEW: Parallax Background
            setupBackground() {
                this.bgStars = [];
                for(let i=0; i<100; i++) {
                    const speed = Math.random() * 0.5 + 0.1;
                    this.bgStars.push({
                        x: Math.random() * this.w,
                        y: Math.random() * this.h,
                        size: Math.random() * 2 + 1,
                        speed: speed,
                        alpha: 0.2 + speed // Fainter for slower (farther) stars
                    });
                }
            }

            initGame() {
                this.started = false;
                this.gameOver = false;
                this.paused = false; // NEW
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.kills = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.multiplier = 1;
                this.slowMotion = false;
                this.slowTimer = 0;

                // NEW: Game state variables
                this.grazeCount = 0;
                this.shakeDuration = 0;
                this.shakeMagnitude = 0;
                
                this.player = {
                    x: this.w / 2,
                    y: this.h - 100,
                    w: 30,
                    h: 30,
                    hp: 100,
                    maxHp: 100,
                    shield: 0,
                    maxShield: 100,
                    special: 0,
                    maxSpecial: 100,
                    cannons: 1,
                    weaponType: 'normal',
                    weaponTimer: 0, // MODIFIED
                    lastShot: 0,
                    invulnerable: 0,
                    magnetRange: 100, // MODIFIED: Give a base magnet range
                    grazeBox: { w: 80, h: 80 } // NEW
                };
                
                this.touchPos = { x: this.w / 2, y: this.h - 100 };
                this.bullets = [];
                this.missiles = [];
                this.enemies = [];
                this.bosses = [];
                this.enemyBullets = [];
                this.particles = [];
                this.powerUps = [];
                this.drones = []; // NEW
                
                this.enemyTimer = 0;
                this.bossTimer = 0;
                this.levelTimer = 0;
                this.currentBoss = null;
                
                // MODIFIED: Added new achievement defs
                this.achievementDefs = [
                    { id: 'first_kill', name: '初次擊殺', desc: '擊殺第一個敵人' },
                    { id: 'graze_100', name: '擦彈大師', desc: '單局擦彈100次' }, // NEW
                    { id: 'combo_10', name: '連擊高手', desc: '達成10連擊' },
                    { id: 'level_5', name: '生存專家', desc: '到達第5級' },
                    { id: 'score_5k', name: '得分王', desc: '單局得分5000' },
                    { id: 'max_cannons', name: '火力全開', desc: '獲得6個炮台' },
                    { id: 'boss_killer', name: 'Boss終結者', desc: '擊敗第一個Boss' },
                    { id: 'total_100', name: '屠殺機器', desc: '累計擊殺100敵人' }
                ];

                document.getElementById('pauseScreen').style.display = 'none'; // NEW
            }
            
            setupControls() {
                const updateTouch = (e) => {
                    if (!this.started || this.gameOver || this.paused) return; // MODIFIED
                    e.preventDefault();
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches ? e.touches[0] : e;
                    this.touchPos.x = (touch.clientX - rect.left) / rect.width * this.w;
                    this.touchPos.y = (touch.clientY - rect.top) / rect.height * this.h;
                };
                
                this.canvas.addEventListener('touchstart', updateTouch);
                this.canvas.addEventListener('touchmove', updateTouch);
                this.canvas.addEventListener('mousedown', updateTouch);
                this.canvas.addEventListener('mousemove', updateTouch);
                
                document.getElementById('specialBtn').onclick = () => this.useSpecial();
                document.getElementById('pauseBtn').onclick = () => this.togglePause(); // NEW

                // NEW: Pause with 'P' key on desktop
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'p') this.togglePause();
                });
                
                document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            }
            
            startGame() {
                this.started = true;
                this.data.totalGames++;
                document.getElementById('startScreen').style.display = 'none';
            }

            // NEW: Pause functionality
            togglePause() {
                if (this.gameOver || !this.started) return;
                this.paused = !this.paused;
                document.getElementById('pauseScreen').style.display = this.paused ? 'block' : 'none';
                document.getElementById('pauseBtn').innerHTML = this.paused ? '▶' : '⏸';
            }
            
            useSpecial() {
                if (this.player.special >= 100 && !this.slowMotion) {
                    this.player.special = 0;
                    this.slowMotion = true;
                    this.slowTimer = 300;
                    document.getElementById('slowmoOverlay').classList.add('active');
                }
            }
            
            autoShoot() {
                const now = Date.now();
                const cooldown = this.slowMotion ? 80 : 120;
                if (now - this.player.lastShot < cooldown) return;
                
                this.player.lastShot = now;
                this.playSound(this.sfx.shoot);
                // NEW: Muzzle flash effect
                this.addParticles(this.player.x + this.player.w/2, this.player.y, '#ffd700', 3, 0.5);

                switch(this.player.weaponType) {
                    case 'missile':
                        this.shootMissile();
                        break;
                    case 'spread': // NEW
                        this.shootSpread();
                        break;
                    case 'piercing': // NEW
                        this.shootPiercing();
                        break;
                    default:
                        this.shootNormal();
                }
            }
            
            shootNormal() {
                const spacing = this.player.w / (this.player.cannons + 1);
                for (let i = 1; i <= this.player.cannons; i++) {
                    this.bullets.push({
                        x: this.player.x + (spacing * i) - 2,
                        y: this.player.y,
                        w: 4, h: 12, speed: 12, damage: 30, type: 'normal'
                    });
                }
            }

            // NEW: Spread shot
            shootSpread() {
                 for (let i = -1; i <= 1; i++) {
                    this.bullets.push({
                        x: this.player.x + this.player.w/2, y: this.player.y,
                        w: 6, h: 6, damage: 25, type: 'normal',
                        vx: i * 2, vy: -10
                    });
                }
            }

            // NEW: Piercing shot
            shootPiercing() {
                this.bullets.push({
                    x: this.player.x + this.player.w/2 - 4, y: this.player.y,
                    w: 8, h: 20, speed: 15, damage: 40, type: 'piercing', hp: 3 // Can hit 3 enemies
                });
            }
            
            shootMissile() {
                const target = this.enemies[0];
                this.missiles.push({
                    x: this.player.x + this.player.w / 2, y: this.player.y,
                    w: 6, h: 10, speed: 8, damage: 80, target: target, vx: 0, vy: -8
                });
            }
            
            // MODIFIED: Added new enemy types
            spawnEnemy() {
                const types = [
                    { w: 35, h: 35, hp: 60, speed: 2.5, color: '#ff4757', pattern: 'spread', points: 100, movement: 'straight' },
                    { w: 45, h: 45, hp: 100, speed: 1.8, color: '#5f27cd', pattern: 'circle', points: 200, movement: 'straight' },
                    { w: 28, h: 28, hp: 40, speed: 3.5, color: '#ff9ff3', pattern: 'aimed', points: 150, movement: 'straight' },
                    { w: 30, h: 30, hp: 80, speed: 2, color: '#32ff7e', pattern: 'none', points: 120, movement: 'sine' }, // NEW: Sine wave movement
                    { w: 50, h: 30, hp: 150, speed: 1.5, color: '#feca57', pattern: 'laser', points: 250, movement: 'straight'} // NEW: Laser
                ];
                
                const type = types[Math.floor(Math.random() * types.length)];
                this.enemies.push({
                    x: Math.random() * (this.w - type.w), y: -type.h,
                    ...type, maxHp: type.hp, lastShot: 0, angle: 0,
                    movementTimer: 0, laserCharge: 0, hitTimer: 0 // NEW
                });
            }
            
            spawnBoss() {
                this.currentBoss = {
                    x: this.w / 2 - 60, y: -120, w: 120, h: 80,
                    hp: 1500, maxHp: 1500, // Increased HP
                    speed: 1, color: '#e74c3c', points: 5000,
                    lastShot: 0, angle: 0,
                    phase: 1, // NEW: Boss phase
                    hitTimer: 0 // NEW
                };
                this.bosses.push(this.currentBoss);
                document.getElementById('bossHealth').style.display = 'block';
            }
            
            // MODIFIED: Added new powerup types
            spawnPowerUp(x, y) {
                if (Math.random() < 0.4) {
                    const types = [
                        { type: 'cannon', color: '#ffd700', symbol: '⚡', rarity: 0.2 },
                        { type: 'health', color: '#ff6b7d', symbol: '❤️', rarity: 0.3 },
                        { type: 'shield', color: '#00d4ff', symbol: '🛡️', rarity: 0.25 },
                        { type: 'missile', color: '#9b59b6', symbol: '🚀', rarity: 0.05 },
                        { type: 'spread', color: '#1dd1a1', symbol: 'S', rarity: 0.05 }, // NEW
                        { type: 'piercing', color: '#f368e0', symbol: 'P', rarity: 0.05 }, // NEW
                        { type: 'drone', color: '#ffffff', symbol: 'O', rarity: 0.05 }, // NEW
                        { type: 'magnet', color: '#ff9f43', symbol: 'M', rarity: 0.05 }, // NEW
                    ];
                    
                    let selected = types[0];
                    const rand = Math.random();
                    let cum = 0;
                    for (const type of types) {
                        cum += type.rarity;
                        if (rand <= cum) { selected = type; break; }
                    }
                    this.powerUps.push({ x: x, y: y, w: 25, h: 25, speed: 2, angle: 0, ...selected });
                }
            }
            
            // MODIFIED: Handle new enemy attack patterns
            enemyShoot(enemy) {
                const now = Date.now();
                let cooldown = this.slowMotion ? 2000 : 1200;
                
                if (enemy.pattern === 'laser') cooldown = 3000;
                if (now - enemy.lastShot < cooldown) return;
                
                enemy.lastShot = now;
                const px = this.player.x + this.player.w / 2;
                const py = this.player.y + this.player.h / 2;

                if (enemy.pattern === 'laser') {
                    if (enemy.laserCharge === 0) { // Start charging
                        enemy.laserCharge = 1;
                        setTimeout(() => { // Fire after a delay
                             if(this.enemies.includes(enemy)) {
                                this.playSound(this.sfx.laser);
                                this.enemyBullets.push({
                                    x: enemy.x + enemy.w / 2, y: enemy.y + enemy.h,
                                    w: 10, h: this.h, type: 'laser', color: enemy.color, life: 30
                                });
                                enemy.laserCharge = 0;
                             }
                        }, 1000);
                    }
                } else if (enemy.pattern === 'spread') {
                    for (let i = -1; i <= 1; i++) {
                        const angle = Math.atan2(py - enemy.y, px - enemy.x) + i * 0.3;
                        this.enemyBullets.push({
                            x: enemy.x + enemy.w / 2, y: enemy.y + enemy.h,
                            w: 6, h: 6, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, color: enemy.color, type: 'normal'
                        });
                    }
                } else if (enemy.pattern === 'circle') {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i + enemy.angle;
                        this.enemyBullets.push({
                            x: enemy.x + enemy.w / 2, y: enemy.y + enemy.h,
                            w: 5, h: 5, vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5, color: enemy.color, type: 'normal'
                        });
                    }
                    enemy.angle += 0.3;
                } else if (enemy.pattern === 'aimed') {
                    const angle = Math.atan2(py - enemy.y, px - enemy.x);
                    this.enemyBullets.push({
                        x: enemy.x + enemy.w / 2, y: enemy.y + enemy.h,
                        w: 8, h: 8, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, color: enemy.color, type: 'normal'
                    });
                }
            }
            
            // MODIFIED: Handle boss phases
            bossShoot(boss) {
                const now = Date.now();
                const px = this.player.x + this.player.w / 2;
                const py = this.player.y + this.player.h / 2;

                if (boss.phase === 1) {
                    if (now - boss.lastShot < 800) return;
                    boss.lastShot = now;
                    for (let i = -2; i <= 2; i++) {
                        const angle = Math.atan2(py - boss.y, px - boss.x) + i * 0.2;
                        this.enemyBullets.push({
                            x: boss.x + boss.w / 2, y: boss.y + boss.h, w: 8, h: 8,
                            vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, color: boss.color, type: 'normal'
                        });
                    }
                } else if (boss.phase === 2) {
                    if (now - boss.lastShot < 400) return; // Shoots faster
                    boss.lastShot = now;
                    // Spiral pattern
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i + boss.angle;
                        this.enemyBullets.push({
                            x: boss.x + boss.w / 2, y: boss.y + boss.h / 2, w: 10, h: 10,
                            vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, color: '#ff9ff3', type: 'normal'
                        });
                    }
                    boss.angle += 0.5;
                }
            }
            
            // MODIFIED: Particle function with more options
            addParticles(x, y, color, count = 8, lifeMultiplier = 1) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: (Math.random() * 20 + 10) * lifeMultiplier,
                        color: color,
                        size: Math.random() * 3 + 1
                    });
                }
            }

            // ... (addCombo, resetCombo, showAchievement are unchanged) ...
            
            addCombo() {
                this.combo++;
                this.comboTimer = 180;
                this.multiplier = Math.min(8, Math.floor(this.combo / 5) + 1); // MODIFIED: Higher max multiplier
                this.player.special = Math.min(100, this.player.special + 2); // MODIFIED: Slower special gain from combo
            }
            
            resetCombo() {
                this.combo = 0;
                this.multiplier = 1;
            }

            checkAchievements() {
                const checks = [
                    { id: 'first_kill', check: () => this.kills >= 1 },
                    { id: 'graze_100', check: () => this.grazeCount >= 100 }, // NEW
                    { id: 'combo_10', check: () => this.combo >= 10 },
                    { id: 'level_5', check: () => this.level >= 5 },
                    { id: 'score_5k', check: () => this.score >= 5000 },
                    { id: 'max_cannons', check: () => this.player.cannons >= 6 },
                    { id: 'boss_killer', check: () => this.bosses.length === 0 && this.currentBoss },
                    { id: 'total_100', check: () => this.data.totalKills >= 100 }
                ];
                
                const newAchievements = [];
                checks.forEach((achievement, i) => {
                    if (!this.data.achievements.includes(achievement.id) && achievement.check()) {
                        this.data.achievements.push(achievement.id);
                        newAchievements.push(this.achievementDefs.find(def => def.id === achievement.id));
                        this.showAchievement(this.achievementDefs.find(def => def.id === achievement.id));
                    }
                });
                
                return newAchievements;
            }

            showAchievement(achievement) {
                const popup = document.getElementById('achievementPopup');
                popup.innerHTML = `🏆 ${achievement.name}<br><small>${achievement.desc}</small>`;
                popup.style.display = 'block';
                setTimeout(() => {
                    popup.style.display = 'none';
                }, 3000);
            }
            
            // NEW: Screen shake helper
            triggerShake(duration, magnitude) {
                this.shakeDuration = duration;
                this.shakeMagnitude = magnitude;
            }

            update() {
                if (!this.started || this.gameOver || this.paused) return; // MODIFIED
                
                // NEW: Screen shake update
                if (this.shakeDuration > 0) this.shakeDuration--;

                // ... (slowMotion timer is unchanged) ...
                if (this.slowMotion) {
                    this.slowTimer--;
                    if (this.slowTimer <= 0) {
                        this.slowMotion = false;
                        document.getElementById('slowmoOverlay').classList.remove('active');
                    }
                }
                
                // ... (player movement is unchanged) ...
                const targetX = this.touchPos.x - this.player.w / 2;
                const targetY = this.touchPos.y - this.player.h / 2;
                this.player.x += (targetX - this.player.x) * 0.15;
                this.player.y += (targetY - this.player.y) * 0.15;
                this.player.x = Math.max(0, Math.min(this.w - this.player.w, this.player.x));
                this.player.y = Math.max(0, Math.min(this.h - this.player.h, this.player.y));
                
                // 自動射擊 & Drones
                this.autoShoot();
                this.drones.forEach(d => d.update(this)); // NEW

                if (this.player.invulnerable > 0) this.player.invulnerable--;
                
                // ... (combo timer is unchanged) ...
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                } else if (this.combo > 0) {
                    this.resetCombo();
                }

                // MODIFIED: Special weapon timer
                if(this.player.weaponTimer > 0) {
                    this.player.weaponTimer--;
                } else {
                    this.player.weaponType = 'normal';
                }
                
                if (this.player.special < 100 && !this.slowMotion) {
                    this.player.special += 0.1;
                }
                
                // MODIFIED: Bullets update
                this.bullets = this.bullets.filter(b => {
                    if (b.speed) b.y -= b.speed * (this.slowMotion ? 1.5 : 1);
                    else {
                        b.x += b.vx; b.y += b.vy;
                    }
                    return b.y > -b.h && b.y < this.h;
                });
                
                // ... (missiles update is unchanged) ...
                this.missiles = this.missiles.filter(m => {
                    if (m.target && this.enemies.includes(m.target)) {
                        const dx = m.target.x - m.x;
                        const dy = m.target.y - m.y;
                        const angle = Math.atan2(dy, dx);
                        m.vx += Math.cos(angle) * 0.5;
                        m.vy += Math.sin(angle) * 0.5;
                        const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
                        if (speed > m.speed) {
                            m.vx = (m.vx / speed) * m.speed;
                            m.vy = (m.vy / speed) * m.speed;
                        }
                    }
                    m.x += m.vx; m.y += m.vy;
                    return m.y > -50 && m.y < this.h + 50;
                });
                
                // MODIFIED: Enemy bullets update
                this.enemyBullets = this.enemyBullets.filter(b => {
                    if (b.type === 'laser') {
                        b.life--;
                        return b.life > 0;
                    }
                    b.x += b.vx * (this.slowMotion ? 0.3 : 1);
                    b.y += b.vy * (this.slowMotion ? 0.3 : 1);
                    return b.x > -50 && b.x < this.w + 50 && b.y > -50 && b.y < this.h + 50;
                });
                
                // MODIFIED: Enemies update
                this.enemies.forEach(e => {
                    if (e.hitTimer > 0) e.hitTimer--;
                    if (e.movement === 'sine') {
                        e.x += Math.sin(e.movementTimer) * 2;
                        e.movementTimer += 0.05;
                    }
                    e.y += e.speed * (this.slowMotion ? 0.3 : 1);
                    this.enemyShoot(e);
                });
                this.enemies = this.enemies.filter(e => e.y < this.h + 60);
                
                // MODIFIED: Boss update
                this.bosses.forEach(boss => {
                    if (boss.hitTimer > 0) boss.hitTimer--;
                    boss.y += boss.speed;
                    if (boss.y > 50) boss.y = 50;
                    
                    if(boss.phase === 1 && boss.hp < boss.maxHp / 2) {
                        boss.phase = 2;
                        this.triggerShake(30, 8); // Phase change effect
                    }
                    this.bossShoot(boss);
                });
                
                // MODIFIED: Power-ups update with magnet
                this.powerUps.forEach(p => {
                    const dx = (this.player.x + this.player.w/2) - (p.x + p.w/2);
                    const dy = (this.player.y + this.player.h/2) - (p.y + p.h/2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < this.player.magnetRange) {
                        p.x += dx / dist * 5;
                        p.y += dy / dist * 5;
                    } else {
                        p.y += p.speed;
                    }
                    p.angle += 0.1;
                });
                this.powerUps = this.powerUps.filter(p => p.y < this.h + 50);
                
                // ... (particles update is unchanged) ...
                this.particles = this.particles.filter(p => {
                    p.x += p.vx; p.y += p.vy;
                    p.vx *= 0.95; p.vy *= 0.95;
                    p.life--;
                    return p.life > 0;
                });
                
                // ... (enemy/boss/level timers are unchanged) ...
                this.enemyTimer++;
                if (this.enemyTimer > Math.max(30, 90 - this.level * 4)) { this.spawnEnemy(); this.enemyTimer = 0; }
                this.bossTimer++;
                if (this.bossTimer > 2400 && this.bosses.length === 0) { this.spawnBoss(); this.bossTimer = 0; }
                this.levelTimer++;
                if (this.levelTimer > 1800) { this.level++; this.levelTimer = 0; }
                
                this.checkCollisions();
                this.checkAchievements();
                this.updateUI();
            }
            
            checkCollisions() {
                // MODIFIED: Weapon collision
                const weapons = [...this.bullets, ...this.missiles];
                weapons.forEach((weapon) => {
                    [...this.enemies, ...this.bosses].forEach((target) => {
                        if (this.collision(weapon, target)) {
                            target.hp -= weapon.damage;
                            target.hitTimer = 5; // NEW: Hit flash
                            this.playSound(this.sfx.hit);

                            if(weapon.type === 'piercing') {
                                weapon.hp--;
                                if(weapon.hp <= 0) this.bullets.splice(this.bullets.indexOf(weapon), 1);
                            } else if (this.bullets.includes(weapon)) {
                                this.bullets.splice(this.bullets.indexOf(weapon), 1);
                            } else {
                                this.missiles.splice(this.missiles.indexOf(weapon), 1);
                            }
                            
                            this.addParticles(weapon.x, weapon.y, '#00d4ff', 4, 0.8);
                            
                            if (target.hp <= 0) {
                                this.score += target.points * this.multiplier;
                                this.kills++;
                                this.data.totalKills++;
                                this.addCombo();
                                this.playSound(this.sfx.explosion);
                                
                                this.spawnPowerUp(target.x + target.w/2, target.y + target.h/2);
                                this.addParticles(target.x + target.w/2, target.y + target.h/2, target.color, 20, 1.5);
                                
                                if (this.bosses.includes(target)) {
                                    this.bosses.splice(this.bosses.indexOf(target), 1);
                                    document.getElementById('bossHealth').style.display = 'none';
                                    this.triggerShake(50, 10); // NEW: Boss explosion shake
                                } else {
                                    this.enemies.splice(this.enemies.indexOf(target), 1);
                                }
                            }
                        }
                    });
                });
                
                // MODIFIED: Player collision
                const playerHitbox = {x: this.player.x, y: this.player.y, w: this.player.w, h: this.player.h};
                this.enemyBullets.forEach((bullet, bi) => {
                    // NEW: Graze detection
                    const grazeHitbox = {
                        x: this.player.x + this.player.w/2 - this.player.grazeBox.w/2,
                        y: this.player.y + this.player.h/2 - this.player.grazeBox.h/2,
                        w: this.player.grazeBox.w,
                        h: this.player.grazeBox.h
                    };
                    if (!bullet.grazed && this.collision(bullet, grazeHitbox)) {
                        bullet.grazed = true;
                        this.grazeCount++;
                        this.score += 10;
                        this.player.special = Math.min(100, this.player.special + 0.5);
                    }

                    if (this.player.invulnerable <= 0 && this.collision(bullet, playerHitbox)) {
                        this.playSound(this.sfx.playerHit);
                        this.triggerShake(20, 5); // NEW: Player hit shake
                        let damage = bullet.type === 'laser' ? 5 : 20;
                        
                        if (this.player.shield > 0) {
                            this.player.shield -= damage;
                            if (this.player.shield < 0) {
                                this.player.hp += this.player.shield;
                                this.player.shield = 0;
                            }
                        } else {
                            this.player.hp -= damage;
                        }
                        
                        this.player.invulnerable = 60;
                        if(bullet.type !== 'laser') this.enemyBullets.splice(bi, 1);
                        this.addParticles(bullet.x, bullet.y, '#ff4757', 10);
                        this.resetCombo();
                        
                        if (this.player.hp <= 0) {
                            this.lives--;
                            this.playSound(this.sfx.explosion);
                            if (this.lives > 0) {
                                this.player.hp = this.player.maxHp;
                                this.player.shield = this.player.maxShield;
                                this.player.invulnerable = 180;
                            } else {
                                this.endGame();
                            }
                        }
                    }
                });
                
                // ... (Player vs powerup collision is unchanged) ...
                this.powerUps.forEach((powerUp, pi) => {
                    if (this.collision(powerUp, this.player)) {
                        this.collectPowerUp(powerUp);
                        this.powerUps.splice(pi, 1);
                    }
                });
            }
            
            collision(rect1, rect2) {
                // Special handling for laser
                if (rect1.type === 'laser' && rect2 === this.player) {
                    return rect2.x < rect1.x + rect1.w && rect2.x + rect2.w > rect1.x && rect2.y < rect1.y + rect1.h;
                }
                return rect1.x < rect2.x + rect2.w &&
                       rect1.x + rect1.w > rect2.x &&
                       rect1.y < rect2.y + rect2.h &&
                       rect1.y + rect1.h > rect2.y;
            }
            
            // MODIFIED: Handle new powerups
            collectPowerUp(powerUp) {
                this.playSound(this.sfx.powerup);
                switch(powerUp.type) {
                    case 'cannon':
                        this.player.cannons = Math.min(6, this.player.cannons + 1);
                        break;
                    case 'health':
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + 50);
                        break;
                    case 'shield':
                        this.player.shield = Math.min(this.player.maxShield, this.player.shield + 50);
                        break;
                    case 'missile':
                    case 'spread':
                    case 'piercing':
                        this.player.weaponType = powerUp.type;
                        this.player.weaponTimer = 600; // 10 seconds
                        break;
                    case 'drone':
                        if (this.drones.length < 2) {
                            this.drones.push(new Drone(this.drones.length));
                        }
                        break;
                    case 'magnet':
                        this.player.magnetRange += 100;
                        setTimeout(() => { this.player.magnetRange -= 100; }, 10000);
                        break;
                }
                
                this.addParticles(powerUp.x + powerUp.w/2, powerUp.y + powerUp.h/2, powerUp.color);
                this.player.special = Math.min(100, this.player.special + 10);
            }
            
            // MODIFIED: Update UI
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('cannons').textContent = this.player.cannons;
                document.getElementById('kills').textContent = this.kills;
                document.getElementById('graze').textContent = this.grazeCount; // NEW
                document.getElementById('combo').textContent = this.combo;
                document.getElementById('multiplier').textContent = this.multiplier;
                
                document.getElementById('healthFill').style.width = (this.player.hp / this.player.maxHp * 100) + '%';
                document.getElementById('shieldFill').style.width = (this.player.shield / this.player.maxShield * 100) + '%';
                document.getElementById('specialFill').style.width = this.player.special + '%';
                
                const specialBtn = document.getElementById('specialBtn');
                if (this.player.special >= 100 && !this.slowMotion) {
                    specialBtn.classList.remove('disabled');
                } else {
                    specialBtn.classList.add('disabled');
                }
                
                if (this.currentBoss && this.bosses.includes(this.currentBoss)) {
                    const bossHp = (this.currentBoss.hp / this.currentBoss.maxHp) * 100;
                    document.getElementById('bossHealthFill').style.width = bossHp + '%';
                }
            }
            
            draw() {
                // NEW: Handle screen shake
                this.ctx.save();
                if (this.shakeDuration > 0) {
                    const shakeX = (Math.random() - 0.5) * this.shakeMagnitude;
                    const shakeY = (Math.random() - 0.5) * this.shakeMagnitude;
                    this.ctx.translate(shakeX, shakeY);
                }

                // MODIFIED: Background drawing
                this.ctx.fillStyle = '#000428';
                this.ctx.fillRect(0,0,this.w,this.h);
                
                this.bgStars.forEach(s => {
                    s.y += s.speed * (this.slowMotion ? 0.3 : 1);
                    if (s.y > this.h) { s.y = 0; s.x = Math.random() * this.w; }
                    this.ctx.globalAlpha = s.alpha;
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillRect(s.x, s.y, s.size, s.size);
                });
                this.ctx.globalAlpha = 1;
                
                if (!this.started || this.paused) { // MODIFIED
                    this.ctx.restore();
                    return;
                }
                
                // NEW: Player thruster particles
                if(Math.random() > 0.3) {
                     this.addParticles(this.player.x + this.player.w/2, this.player.y + this.player.h, '#ffc53d', 1, 0.2);
                }
                
                // ... (Drawing logic is largely the same, but with new elements and effects) ...
                
                // Player
                this.ctx.save();
                if (this.player.invulnerable > 0 && Math.floor(this.player.invulnerable / 5) % 2) {
                    this.ctx.globalAlpha = 0.5;
                }
                if (this.player.shield > 0) {
                    this.ctx.strokeStyle = '#00d4ff'; this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 10; this.ctx.shadowColor = '#00d4ff';
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x + this.player.w/2, this.player.y + this.player.h/2, this.player.w + 8, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                this.ctx.fillStyle = '#00d4ff';
                this.ctx.shadowBlur = 15; this.ctx.shadowColor = '#00d4ff';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + this.player.w/2, this.player.y);
                this.ctx.lineTo(this.player.x, this.player.y + this.player.h);
                this.ctx.lineTo(this.player.x + this.player.w/2, this.player.y + this.player.h*0.7);
                this.ctx.lineTo(this.player.x + this.player.w, this.player.y + this.player.h);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.restore();

                // NEW: Draw drones
                this.drones.forEach(d => d.draw(this.ctx));
                
                // Player Bullets
                this.ctx.shadowBlur = 5;
                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.type === 'piercing' ? '#f368e0' : '#00d4ff';
                    this.ctx.shadowColor = b.type === 'piercing' ? '#f368e0' : '#00d4ff';
                    this.ctx.fillRect(b.x, b.y, b.w, b.h);
                });
                this.missiles.forEach(m => {
                    this.ctx.fillStyle = '#9b59b6'; this.ctx.shadowColor = '#9b59b6';
                    this.ctx.fillRect(m.x, m.y, m.w, m.h);
                    this.addParticles(m.x + m.w/2, m.y + m.h, '#9b59b6', 1, 0.5);
                });
                
                // Enemies
                this.enemies.forEach(e => {
                    this.ctx.save();
                    if(e.hitTimer > 0) this.ctx.fillStyle = '#ffffff';
                    else this.ctx.fillStyle = e.color;
                    this.ctx.shadowColor = e.color; this.ctx.shadowBlur = 10;
                    this.ctx.fillRect(e.x, e.y, e.w, e.h);
                    this.ctx.restore();
                    
                    const hpPercent = e.hp / e.maxHp;
                    this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    this.ctx.fillRect(e.x, e.y - 6, e.w, 3);
                    this.ctx.fillStyle = hpPercent > 0.5 ? '#4CAF50' : hpPercent > 0.25 ? '#FFC107' : '#F44336';
                    this.ctx.fillRect(e.x, e.y - 6, e.w * hpPercent, 3);
                    
                    // NEW: Laser charge indicator
                    if (e.pattern === 'laser' && e.laserCharge > 0) {
                        this.ctx.strokeStyle = e.color; this.ctx.lineWidth = 2;
                        this.ctx.beginPath(); this.ctx.moveTo(e.x + e.w/2, e.y + e.h); this.ctx.lineTo(e.x + e.w/2, this.h);
                        this.ctx.stroke();
                    }
                });
                
                // Boss
                this.bosses.forEach(boss => {
                    this.ctx.save();
                    if (boss.hitTimer > 0) this.ctx.fillStyle = '#ffffff';
                    else this.ctx.fillStyle = boss.color;

                    this.ctx.shadowBlur = 15; this.ctx.shadowColor = boss.color;
                    this.ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
                    
                    // NEW: More detailed boss drawing
                    this.ctx.fillStyle = boss.phase === 2 ? '#ff9ff3' : '#fff';
                    this.ctx.fillRect(boss.x + boss.w/2 - 10, boss.y + 20, 20, 20); // "Eye"
                    this.ctx.restore();
                });
                
                // Enemy Bullets
                this.enemyBullets.forEach(b => {
                    this.ctx.fillStyle = b.color;
                    this.ctx.shadowColor = b.color;
                    this.ctx.shadowBlur = 5;
                    if(b.type === 'laser') {
                        this.ctx.globalAlpha = b.life / 30;
                        this.ctx.fillRect(b.x - b.w/2, b.y, b.w, b.h);
                        this.ctx.globalAlpha = 1;
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(b.x + b.w/2, b.y + b.h/2, b.w/2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
                
                // Powerups
                this.ctx.shadowBlur = 8;
                this.powerUps.forEach(p => {
                    this.ctx.save();
                    this.ctx.translate(p.x + p.w/2, p.y + p.h/2); this.ctx.rotate(p.angle);
                    this.ctx.fillStyle = p.color; this.ctx.shadowColor = p.color;
                    this.ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
                    this.ctx.restore();
                    this.ctx.fillStyle = '#000'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign = 'center';
                    this.ctx.fillText(p.symbol, p.x + p.w/2, p.y + p.h/2 + 6);
                });
                
                // Particles
                this.ctx.shadowBlur = 0;
                this.particles.forEach(p => {
                    this.ctx.globalAlpha = p.life / 30;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
                
                // ... (Combo display text is unchanged) ...
                if (this.combo > 5) {
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.font = `${16 + this.combo}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = '#ffd700';
                    this.ctx.fillText(`${this.combo} COMBO!`, this.w / 2, this.h / 2 - 80);
                }
                if (this.slowMotion) {
                    this.ctx.fillStyle = 'rgba(0, 150, 255, 0.8)';
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('SLOW MOTION', this.w / 2, 60);
                }
                
                this.ctx.shadowBlur = 0;
                this.ctx.restore(); // NEW: Restore from screen shake translate
            }
            
            // MODIFIED: Added more stats to game over screen
            endGame() {
                this.gameOver = true;
                
                if (this.score > this.data.highScore) {
                    this.data.highScore = this.score;
                }
                
                const newAchievements = this.checkAchievements();
                this.saveData();
                
                document.getElementById('finalStats').innerHTML = `
                    <div class="stats-grid">
                        <div>最終分數: <strong>${this.score}</strong></div>
                        <div>最高分: <strong>${this.data.highScore}</strong></div>
                        <div>到達等級: <strong>${this.level}</strong></div>
                        <div>總擊殺: <strong>${this.kills}</strong></div>
                        <div>最高連擊: <strong>${this.combo}</strong></div>
                        <div>總擦彈數: <strong>${this.grazeCount}</strong></div>
                    </div>
                `;
                
                if (newAchievements.length > 0) {
                    document.getElementById('newAchievements').innerHTML = `
                        <h3>🎉 新成就解鎖！</h3>
                        ${newAchievements.map(a => `<div>✨ ${a.name}: ${a.desc}</div>`).join('')}
                    `;
                } else {
                    document.getElementById('newAchievements').innerHTML = '';
                }
                
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restart() {
                document.getElementById('gameOver').style.display = 'none';
                this.initGame();
                this.startGame();
            }
            
            backToMenu() {
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('pauseScreen').style.display = 'none';
                document.getElementById('startScreen').style.display = 'block';
                this.updateStartScreen();
                this.initGame();
            }
            
            loop() {
                if(!this.paused) {
                    this.update();
                }
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        // NEW: Drone (僚機) Class
        class Drone {
            constructor(index) {
                this.index = index; // 0 for left, 1 for right
                this.angle = 0;
                this.lastShot = 0;
                this.x = 0;
                this.y = 0;
            }

            update(game) {
                this.angle += 0.05;
                const offsetX = (this.index === 0 ? -1 : 1) * 60;
                this.x = game.player.x + game.player.w/2 + offsetX;
                this.y = game.player.y + 20 + Math.sin(this.angle) * 10;

                const now = Date.now();
                if (now - this.lastShot > 400) {
                    this.lastShot = now;
                    game.bullets.push({
                        x: this.x - 2, y: this.y, w: 4, h: 8, speed: 10, damage: 15, type: 'normal'
                    });
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        const game = new Game();
    </script>
</body>
</html>